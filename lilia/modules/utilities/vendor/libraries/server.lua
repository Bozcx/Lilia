NAME = "English"
LANGUAGE = {
    mustProvideString = "Must Provide String",
    use = "Use",
    modules = "Modules",
    faction = "Faction",
    none = "None",
    class = "Class",
    leave = "Leave",
    name = "Name",
    model = "Model",
    flag = "Flag",
    search = "Search...",
    disable = "Disable",
    generatedWeapon = "Generated weapon: %s",
    invalidFaction = "The specified faction is not valid.",
    submit = "Submit",
    cfgSet = "%s has set \"%s\" to %s.",
    create = "Create",
    desc = "Description",
    noDesc = "No description available",
    invalid = "You have provided an invalid %s",
    descMinLen = "Your description must be at least %d character(s).",
    unknown = "Unknown",
    unknownError = "An unknown error has occured",
    author = "Author",
    version = "Version",
    characterGeneric = "Character:",
    settings = "Settings",
    config = "Config",
    chat = "Chat",
    appearance = "Appearance",
    misc = "Miscellaneous",
    home = "Home",
    quickSettings = "Quick Settings",
    altLower = "Hide hands when lowered?",
    edit = "Edit",
    you = "You",
    flags = "Flags",
    help = "Help",
    commands = "Commands",
    helpDefault = "Select a category",
    classes = "Classes",
    tooFar = "Too Far!",
    targetTooFar = "The target is too far away!",
    mustBeOnCharacter = "You must be on a character to use this.",
    lookToUseAt = "You need to be looking at someone to use '@'",
    plyNotValid = "You are not looking at a valid player.",
    commandCooldown = "This command is on cooldown!",
    commandCooldownTimed = "This command is on cooldown! Time remaining: %d seconds.",
    dbError = "Database connection failed",
    itemNoExist = "Sorry, the item that you requested does not exist.",
    cmdNoExist = "Sorry, that command does not exist.",
    plyNoExist = "Sorry, a matching player could not be found.",
    itemInfo = "Name: %s\nDescription: %s",
    itemCreated = "Item successfully created.",
    inv = "Inventory",
    drop = "Drop",
    dropTip = "Drops this item from your inventory.",
    take = "Take",
    takeTip = "Take this item and place it in your inventory.",
    canNotAfford = "You can not afford to purchase this.",
    notOwner = "You are not the owner of this.",
    invalidArg = "Invalid argument.",
    noFit = "This item can not fit in your inventory.",
    noOwner = "The owner is invalid.",
    invalidIndex = "The Item Index is Invalid.",
    invalidItem = "The Item Object is Invalid.",
    invalidInventory = "The Inventory Object is Invalid.",
    equippedBag = "Equipped items cannot moved between inventories.",
    useTip = "Uses the item.",
    equipTip = "Equips the item.",
    unequipTip = "Unequips the item.",
    itemOnGround = "Your item has been placed on the ground.",
    forbiddenActionStorage = "You can't do this action with storaged item.",
    cantDropBagHasEquipped = "You can't drop bag that has equipped item.",
    needModel = "You need to choose a valid model",
    creating = "Your character is being created...",
    usingChar = "You are already using this character.",
    playerCharBelonging = "This object is your other character's belonging.",
    descChanged = "You have changed your character's description.",
    charMoney = "You currently have %s.",
    charFaction = "You are a member of the %s faction.",
    charClass = "You are %s of the faction.",
    charKick = "%s kicked character %s.",
    charBan = "%s banned the character %s.",
    charBanned = "This character is banned.",
    charUnBan = "%s has unbanned the character %s.",
    charNotBanned = "This character isn't banned!",
    limitFaction = "This faction is full. Try again later.",
    salary = "You have received %s from your salary.",
    locking = "Locking this entity...",
    unlocking = "Unlocking this entity...",
    notNow = "You are not allowed to do this right now.",
    illegalAccess = "You don't have access to this!",
    moneyTaken = "You found %s.",
    gettingUp = "You are now getting up...",
    weapons = "Weapons",
    noPerm = "You are not allowed to do this.",
    chgName = "Change Name",
    chgNameDesc = "Enter the character's new name below.",
    whitelist = "%s has whitelisted %s for the %s faction.",
    unwhitelist = "%s has unwhitelisted %s from the %s faction.",
    load = "Load",
    equip = "Equip",
    unequip = "Unequip",
    view = "View",
    ["goto"] = "Go to",
    ["return"] = "Return",
    freeze = "Freeze",
    bring = "Bring",
    oocDelay = "You must wait %s more second(s) before using OOC again.",
    loocDelay = "You must wait %s more second(s) before using LOOC again.",
    becomeClassFail = "Failed to become %s.",
    becomeClass = "You have become %s.",
    characters = "Characters",
    characterLabel = "Character",
    weaponSelector = "Weapon Selector",
    scoreboard = "Scoreboard",
    flagGive = "%s has given %s '%s' flags.",
    flagGiveTitle = "Give Flags",
    flagGiveDesc = "Give the following flags to the player.",
    flagTake = "%s has taken '%s' flags from %s.",
    flagTakeTitle = "Take Flags",
    flagTakeDesc = "Remove the following flags from the player.",
    flagNoMatch = "You must have \"%s\" Flag(s) to do this action.",
    spawnAdd = "You have added a spawn for the %s.",
    spawnDeleted = "You have removed %s spawn point(s).",
    spawnAdded = "You added spawn for %s.",
    attribSet = "You set %s's %s to %s.",
    attribUpdate = "You added %s's %s by %s.",
    toggleObserverTP = "Toggle Observer teleport",
    toggleESP = "Toggle Admin ESP",
    toggleESPAdvanced = "ESP Advanced Mode",
    Author = "Author",
    Contact = "Contact",
    Purpose = "Purpose",
    Instructions = "Instructions",
    invertWeaponScroll = "Invert Weapon Scroll",
    invertWeaponScrollDesc = "Invert the weapon selection scroll direction",
    sbWidth = "Scoreboard Width",
    sbWidthDesc = "Scoreboard Width",
    sbHeight = "Scoreboard Height",
    sbHeightDesc = "Scoreboard Height",
    showStaff = "Show Staff in Scoreboard",
    showStaffDesc = "Should Staff Show In Scoreboard",
    displayServerName = "Display Server Name in Scoreboard",
    displayServerNameDesc = "Should Server Name Show In Scoreboard",
    useSolidBackground = "Use Solid Background in Scoreboard",
    useSolidBackgroundDesc = "Use a solid background for the scoreboard",
    scoreboardBackgroundColor = "Scoreboard Background Color",
    scoreboardBackgroundColorDesc = "Sets the background color of the scoreboard. This only applies if 'Use Solid Background' is enabled.",
    playersOnline = "Players Online: %d",
    staffOnDuty = "Staff On Duty: %d",
    staffOnline = "Staff Online: %d",
    sbOptions = "Scoreboard Options: %s",
    thirdpersonToggle = "Toggle Thirdperson",
    thirdpersonClassic = "Use Classic Thirdperson",
    thirdpersonConfig = "Thirdperson Configuration",
    thirdPersonEnabled = "Enable Third-Person View",
    thirdPersonEnabledDesc = "Allows players to toggle third-person view on or off.",
    maxThirdPersonDistance = "Maximum Third-Person Distance",
    maxThirdPersonDistanceDesc = "The maximum allowable camera distance in third-person view.",
    maxThirdPersonHorizontal = "Maximum Third-Person Horizontal Offset",
    maxThirdPersonHorizontalDesc = "The maximum allowable horizontal offset for third-person view.",
    maxThirdPersonHeight = "Maximum Third-Person Height Offset",
    maxThirdPersonHeightDesc = "The maximum allowable vertical offset for third-person view.",
    maxViewDistance = "Maximum View Distance",
    maxViewDistanceDesc = "The maximum distance (in units) at which players are visible.",
    thirdPersonEnabledOption = "Third Person Enabled",
    thirdPersonEnabledOptionDesc = "Toggle third-person view.",
    thirdPersonClassicModeOption = "Third Person Classic Mode",
    thirdPersonClassicModeOptionDesc = "Enable classic third-person view mode.",
    thirdPersonHeightOption = "Third Person Height",
    thirdPersonHeightOptionDesc = "Adjust the vertical height of the third-person camera.",
    thirdPersonHorizontalOption = "Third Person Horizontal",
    thirdPersonHorizontalOptionDesc = "Adjust the horizontal offset of the third-person camera.",
    thirdPersonDistanceOption = "Third Person Distance",
    thirdPersonDistanceOptionDesc = "Adjust the camera distance in third-person view.",
    thirdPersonCategory = "Third Person",
    doorTitle = "Unowned Door",
    doorTitleOwned = "Owned Door",
    doorIsNotOwnable = "This door cannot be owned.",
    doorIsOwnable = "You can purchase this door by pressing F2.",
    doorMadeUnownable = "This door is now unownable.",
    doorMadeOwnable = "This door is now ownable.",
    doorNotAllowedToOwn = "You are not allowed to own this door.",
    doorSetDisabled = "This door is now disabled.",
    doorSetNotDisabled = "This door is no longer disabled.",
    doorSetHidden = "This door is now hidden.",
    doorSetNotHidden = "This door is no longer hidden.",
    doorSetParentDoor = "This door has been set as the parent door.",
    doorCanNotSetAsChild = "The parent door cannot be set as a child.",
    doorAddChildDoor = "This door has been added as a child.",
    doorRemoveChildren = "All child doors have been removed.",
    doorRemoveChildDoor = "This door has been removed as a child.",
    doorNoParentDoor = "No parent door has been set.",
    doorOwnedBy = "This door is owned by %s.",
    doorConfigName = "Doors",
    doorSetFaction = "This door now belongs to the '%s' faction.",
    doorRemoveFaction = "This door no longer belongs to any faction.",
    doorSettings = "Door Settings",
    doorPurchased = "You have purchased this door for %s.",
    doorSold = "You have sold this door for %s.",
    doorNotValid = "You are not looking at a valid door.",
    doorNotOwner = "You do not own this door.",
    doorCanNotAfford = "You cannot afford this door.",
    doorAlreadyDisabled = "This door is already disabled.",
    doorAlreadyEnabled = "This door is already enabled.",
    doorToggleLocked = "The door has been %s.",
    doorSetTitle = "The door title has been set to '%s'.",
    invalidClass = "The specified class is not valid.",
    doorDisabled = "This door is currently disabled.",
    doorDisableAll = "All doors have been disabled (%d total).",
    doorEnableAll = "All doors have been enabled (%d total).",
    doorForceLock = "The door has been forcibly locked.",
    doorForceUnlock = "The door has been forcibly unlocked.",
    doorSetClass = "This door now belongs to the '%s' class.",
    doorRemoveClass = "This door no longer belongs to any class.",
    doorSaveData = "Door data has been saved.",
    locked = "Locked",
    unlocked = "Unlocked",
    doorPrice = "Price: %s",
    doorName = "Name",
    doorAccess = "Access",
    doorTenant = "Tenant",
    doorGuest = "Guest",
    doorNone = "None",
    doorSell = "Sell",
    doorFactions = "Factions:",
    doorClasses = "Classes:",
    doorAddFaction = "Add Faction to Door",
    doorRemoveFactionAdmin = "Remove Faction from Door",
    doorNoFactions = "No factions assigned to this door",
    doorSetDoorClass = "Set Door Class",
    doorRemoveDoorClass = "Remove Class",
    doorLockTime = "Door Lock Time",
    doorLockTimeDesc = "Time it takes to lock a door",
    doorSellRatio = "Door Sell Ratio",
    doorSellRatioDesc = "Percentage you can sell a door for",
    recognize = "Allow this character to recognize you.",
    recognized = "You gave this character your identity.",
    already_recognized = "This character already knows you.",
    noRecog = "You do not recognize this person.",
    someone = "someone",
    someoneUnrecognized = "someone you don't recognize",
    pktoggle_true = "You have toggled this character's PK State to True. They will be PK'ed the next time they die!",
    pktoggle_false = "You have toggled this character's PK State to False.",
    charPK_target_not_found = "Target player not found or they do not have an active character.",
    charPK_success_admin = "You have permanently killed %s's character.",
    charPK_success_target = "Your character has been permanently killed by %s.",
    storPass = "You've set this storage's password to %s.",
    storPassRmv = "You've removed this storage's password.",
    storPassWrite = "Enter the password.",
    wrongPassword = "You've entered the wrong password.",
    notLookingAtVehicle = "You're not looking at any vehicle!",
    tooFarToOpenTrunk = "You're too far to open the trunk!",
    openingTrunk = "Opening...",
    unauthorizedNetMessage = "Unauthorized use of net message: %s",
    unprotectedVJNetCallLog = "[%s] %s triggered unprotected net message '%s'",
    logCategoryVJNet = "VJ Base",
    logTypeUnprotectedVJNetCall = "Unprotected VJ Net Call",
    staffPermissionDenied = "You lack the required permissions to execute this command.",
    staffRestrictedCommand = "You do not have permission to run this command. This command is restricted to staff members.",
    DisplayStaffCommands = "Display Staff Commands",
    DisplayStaffCommandsDesc = "Controls whether notifications and commands for staff are displayed.",
    AdminOnlyNotification = "Admin Only Notifications",
    AdminOnlyNotificationDesc = "Restricts certain notifications to admins with specific permissions or those on duty.",
    SAMEnforceStaff = "Enforce Staff Rank To SAM",
    SAMEnforceStaffDesc = "Determines whether staff enforcement for SAM commands is enabled.",
    StaffCategory = "Staff",
    ProtectionCategory = "Protection",
    playtimeYour = "Your playtime: %d hours, %d minutes, %d seconds",
    playtimeError = "Could not retrieve your playtime. Please try again or contact an admin if the issue persists.",
    specifyPlayer = "You must specify a player name.",
    playerNotFound = "Player not found.",
    playtimeFor = "Playtime for %s: %d hours, %d minutes, %d seconds",
    playtimeTargetError = "Could not retrieve playtime for the specified target.",
    adminStickGetPlayTimeName = "Get Play Time",
    adminStickCategoryModeration = "Moderation Tools",
    adminStickSubCategoryMisc = "Miscellaneous",
    fixpac_success = "PAC has been successfully restarted. You might need to run this command twice!",
    pacdisable_message = "PAC has been disabled to boost performance. If you would like to re-enable it, type /pacenable in chat.",
    vehicleLocked = "This vehicle is locked!",
    someoneEnteringCar = "Someone is entering this car!",
    enteringVehicleAction = "Entering Vehicle...",
    configDamageInCars = "Take Damage in Cars",
    configDamageInCarsDesc = "Whether or not you take damage while in cars",
    vendorDefaultMoney = "Default Vendor wMoney",
    vendorMoneyDesc = "Sets the default amount of money a vendor starts with.",
    vendorCategory = "Vendor",
    vendorSellScale = "Sell price scale",
    vendorNoTrade = "You are not able to trade with this vendor.",
    vendorNoMoney = "This vendor cannot afford that item.",
    vendorNoStock = "This vendor does not have that item in stock.",
    vendorPriceReq = "Enter the new price for this item.",
    vendorEditCurStock = "Edit Current Stock",
    vendorEditor = "Vendor Editor",
    vendorWelcome = "Welcome to my store, what can I get you today?",
    vendorNoSellItems = "There are no items available for sale.",
    vendorNoBuyItems = "There are no items available for purchase.",
    vendorSettings = "Vendor Settings",
    vendorTradeRestrictedFlag = "You do not have the required permissions to trade this item.",
    vendorUseMoney = "Should the vendor use money?",
    vendorYouSoldItem = "You sold %s for %s.",
    vendorYouBoughtItem = "You bought %s for %s.",
    vendorSteamIDWhitelist = "You are not whitelisted via SteamID.",
    vendorFactionWhitelist = "You are not whitelisted for this faction.",
    vendorUserGroupWhitelist = "You are not whitelisted for this user group.",
    vendorVIPOnly = "This item is available for VIPs only.",
    vendorNotWhitelisted = "You are not whitelisted to trade this item.",
    vendorError = "An error occurred during the transaction.",
    vendorPrice = "Price",
    vendorStock = "Stock",
    vendorNone = "None",
    vendorBoth = "Buy and Sell",
    vendorBuy = "Buy Only",
    vendorSell = "Sell Only",
    vendorMaxStock = "Maximum Stock",
    vendorFaction = "Faction Editor",
    vendorBye = "Come again soon!",
    vendorMode = "Mode",
    vendorChangePlayermodel = "Change Playermodel",
    vendorSellAction = "Sell for %s",
    vendorBuyAction = "Buy for %s",
    vendorFree = "Free",
    vendorShowAll = "Show All Items",
    vendorShowCategories = "Show Categories",
    vendorHideCategories = "Hide Categories",
    vendorYourItems = "Your Items",
    vendorItems = "Vendor's Items",
    vendorEditorButton = "Editor",
    vendorDescription = "Description:",
    vendorFactionLabel = "Faction:",
    vendorMoney = "Money:",
    vendorItemCount = "Item Count:",
    vendorYourItemCount = "Your Items: %d %s",
    vendorDoesNotHaveItem = "The vendor does not have this item.",
    vendorSellOnly = "This vendor only allows selling this item.",
    vendorBuyOnly = "This vendor only allows buying this item.",
    vendorPlayerDoesNotHaveItem = "You do not have this item.",
    vendorError = "An error occurred during the transaction.",
    vendorNoInventorySpace = "You don't have enough space for this item!",
    vendorRestocked = "The vendor has been restocked.",
    vendorNotLookingAtValidVendor = "You are not looking at a valid vendor.",
    vendorAllVendorsRestocked = "All vendors have been restocked. Total vendors restocked: %d.",
    vendorInvalidAmount = "Invalid amount specified.",
    vendorAllMoneyReset = "All vendors' money has been reset to %s. Total vendors updated: %d.",
    vendorMoneyRestocked = "Vendor's money has been restocked to %s.",
    vendorNoMoneyVariable = "This vendor does not have a money variable.",
    vendorDataSaved = "All vendor data has been saved.",
    vendorInvalidItem = "Invalid item.",
    vendorCanNotAfford = "You cannot afford that item.",
    vendorAmountSaved = "Vendors saved: %d.",
    vendorLogAccess = "[%s] %s accessed vendor %s [CharID: %s]",
    vendorLogExit = "[%s] %s exited vendor %s [CharID: %s]",
    vendorLogSell = "[%s] %s sold a %s to %s [CharID: %s]",
    vendorLogEdit = "[%s] %s edited vendor %s with key %s [CharID: %s]",
    vendorLogBuySuccess = "[%s] %s bought a %s from %s [CharID: %s]",
    vendorLogBuyFail = "[%s] %s tried to buy a %s from %s but it failed. They likely had no space! [CharID: %s]",
    ammoLoadAll = "Load All",
    ammoLoadAmount = "Load %s",
    ammoLoadCustom = "Load...",
    ammoDesc = "A Box that contains %s of Pistol Ammo",
    bagAlreadyEquipped = "There's already a bag equipped!",
    factionStaffName = "Staff on Duty",
    factionStaffDesc = "The Staff",
    sameOutfitCategory = "You are already wearing this type of outfit.",
    invalidWeapon = "Invalid Weapon",
    weaponSlotFilled = "This weapon slot is filled!",
    weaponDoesNotExist = "Weapon %s does not exist!",
    noRagdollAction = "You cannot do this while ragdolled.",
    placeDownEntity = "Place Down This Entity.",
    cleaningFinished = "You cleaned up %s: %s entities removed.",
    moneyLimit = "You can't drop more than 3 pieces of money at a time.",
    invalidTarget = "Invalid Target!",
    noRagdoll = "You don't have a ragdoll to get up from!",
    invCheckSelf = "This isn't meant for checking your own inventory.",
    noValidPlayers = "No valid players found!",
    noOnDutyStaff = "No on-duty staff members found!",
    noBodygroups = "No bodygroups available for this model.",
    mustSpecifyItem = "You must specify an item to give.",
    freezeAllProps = "You have frozen all of %s's Entities.",
    freezeAllPropsCount = "Frozen %s Entities belonging to %s.",
    enterNewDesc = "Enter new description",
    mustSpecifySound = "You must specify a sound to play.",
    invalidTargetOrSound = "Invalid target or sound.",
    waitRespawn = "Wait until you respawn.",
    noDeathPosition = "No death position saved.",
    invalidAmount = "Invalid amount.",
    noMoney = "You don't have enough money.",
    needLookAt = "You need to be looking at someone!",
    cmdCooldown = "This Command Is In Cooldown!",
    cmdFrozen = "You cannot use this while frozen!",
    cmdDead = "You cannot use this while dead!",
    cmdVehicle = "You cannot use this as you are in a vehicle!",
    cmdNoclip = "You cannot use this while in noclip!",
    moneyCooldown = "You can't use this command yet. Cooldown remaining: %s seconds.",
    lackFunds = "You lack the funds for this!",
    resetInv = "You have cleared %s's inventory!",
    searchingChar = "Searching for character...",
    noAvailableFlags = "No available flags to give.",
    gaveAllFlags = "You gave this player all flags!",
    tookAllFlags = "You took this player's flags!",
    itemGiven = "You gave the item to %s: %s",
    charInvEmpty = "Character Inventory is empty.",
    changedScale = "You changed %s's model scale to %s.",
    changedJump = "You changed %s's jump power to %s.",
    setMoney = "You set %s's money to %s.",
    addMoney = "You gave %s an additional %s. Total: %s",
    noMessage = "You must specify a message.",
    needBotAndMessage = "You must specify a bot and a message.",
    botNotFound = "No bot found with the name: %s",
    givenMoneyTarget = "You were given %s by %s",
    givenMoneyClient = "You gave %s to %s",
    changeModel = "%s changed %s's model to %s.",
    changeName = "%s changed %s's name to %s.",
    changeSkin = "%s changed %s's skin to %s.",
    changeBodygroups = "%s changed %s's \"%s\" bodygroup to %s.",
    exploitDropWarning = "Player %s attempted to drop more than 3 pieces of money. Potential exploit!",
    adminStickCheckInventoryName = "Check Inventory",
    adminStickChangeName = "Change Name",
    adminStickClearInventoryName = "Clear Inventory",
    adminStickKickCharacterName = "Kick Character",
    adminStickBanCharacterName = "Ban Character",
    adminStickCategoryCharManagement = "Character Management",
    adminStickSubCategoryItems = "Items",
    adminStickSubCategoryBans = "Bans",
    adminStickCategoryPlayerInfos = "Player Informations",
    adminStickSubCategoryGetInfos = "Get Informations",
    adminStickSubCategorySetInfos = "Set Informations",
    adminStickSetCharSpeedName = "Set Character Speed",
    adminStickSetCharModelName = "Set Character Model",
    adminStickGiveItemName = "Give Item",
    adminStickSetCharDescName = "Set Character Description",
    adminStickSetCharNameName = "Set Character Name",
    adminStickSetCharScaleName = "Set Character Scale",
    adminStickSetCharJumpName = "Set Character Jump Height",
    adminStickTakeAllFlagsName = "Take All Flags",
    adminStickGiveAllFlagsName = "Give All Flags",
    adminStickCheckMoneyName = "Check Money",
    adminStickGetCharFlagsName = "Get Character Flags",
    uiFlagList = "Flag List",
    uiItemList = "Item List",
    uiModulesList = "Modules List",
    uiEntityList = "Entity List",
    uiStaffList = "Staff List",
    uiOnDutyStaffFlags = "On Duty Staff Flags",
    uiOnDutyStaffList = "On Duty Staff List",
    uiVIPList = "VIP List",
    uiUserList = "User List",
    uiBodygroupsFor = "Bodygroups for %s",
    groupID = "Group ID",
    range = "Range",
    characterID = "Character ID",
    usergroup = "Usergroup",
    playerMoney = "%s has %d",
    adminStickGetCharModelName = "Get Character Model",
    adminStickGetCharNameName = "Get Character Name",
    adminStickGetCharHealthName = "Get Character Health",
    adminStickGetCharMoneyName = "Get Character Money",
    adminStickGetCharInventoryName = "Get Character Inventory",
    sendToSitRoom = "Send To Sit RoomTools",
    ["Moderation Tools"] = "Moderation Tools",
    ["Player Informations"] = "Player Informations",
    ["Character Management"] = "Character Management",
    ["Flags Management"] = "Flags Management",
    ["Give Flags"] = "Give Flags",
    ["Take Flags"] = "Take Flags",
    ["Cancel"] = "Cancel",
    ["Reason"] = "Reason",
    ["Reason for %s"] = "Reason for %s",
    ["Length (days)"] = "Length (days)",
    ["Change Playermodel"] = "Change Playermodel"
}

function MODULE:SaveData()
    local data = {}
    for _, v in ipairs(ents.FindByClass("lia_vendor")) do
        data[#data + 1] = {
            name = v:getNetVar("name"),
            pos = v:GetPos(),
            angles = v:GetAngles(),
            model = v:GetModel(),
            items = v.items,
            factions = v.factions,
            classes = v.classes,
            money = v.money,
            flag = v:getNetVar("flag"),
            scale = v:getNetVar("scale")
        }
    end

    self:setData(data)
    LiliaInformation("vendorAmountSaved", table.Count(data))
end

function MODULE:LoadData()
    for _, v in ipairs(self:getData() or {}) do
        local entity = ents.Create("lia_vendor")
        entity:SetPos(v.pos)
        entity:SetAngles(v.angles)
        entity:Spawn()
        entity:SetModel(v.model)
        entity:setNetVar("name", v.name)
        entity:setNetVar("flag", v.flag)
        entity:setNetVar("scale", v.scale or 0.5)
        entity.items = v.items or {}
        entity.factions = v.factions or {}
        entity.classes = v.classes or {}
        entity.money = v.money
    end
end

function MODULE:OnCharTradeVendor(client, vendor, item, isSellingToVendor, _, _, isFailed)
    local vendorName = vendor:getNetVar("name") or "Unknown"
    if not isSellingToVendor then
        lia.log.add(client, "vendorBuy", item:getName(), vendorName, isFailed)
    else
        lia.log.add(client, "vendorSell", item:getName(), vendorName)
    end
end

function MODULE:CanPlayerAccessVendor(client, vendor)
    local character = client:getChar()
    local flag = vendor:getNetVar("flag")
    if client:CanEditVendor() then return true end
    if vendor:isClassAllowed(character:getClass()) then return true end
    if vendor:isFactionAllowed(client:Team()) then return true end
    if flag and string.len(flag) == 1 and client:getChar():hasFlags(flag) then return true end
end

function MODULE:CanPlayerTradeWithVendor(client, vendor, itemType, isSellingToVendor)
    local item = lia.item.list[itemType]
    if not item then return false, L("vendorInvalidItem") end
    local SteamIDWhitelist = item.SteamIDWhitelist
    local FactionWhitelist = item.FactionWhitelist
    local UserGroupWhitelist = item.UsergroupWhitelist
    local VIPOnly = item.VIPWhitelist
    local flag = item.flag
    if not vendor.items[itemType] then return false, L("vendorDoesNotHaveItem") end
    local state = vendor:getTradeMode(itemType)
    if isSellingToVendor and state == VENDOR_SELLONLY then return false, L("vendorSellOnly") end
    if not isSellingToVendor and state == VENDOR_BUYONLY then return false, L("vendorBuyOnly") end
    if isSellingToVendor then
        if not client:getChar():getInv():hasItem(itemType) then return false, L("vendorPlayerDoesNotHaveItem") end
    else
        local stock = vendor:getStock(itemType)
        if stock and stock <= 0 then return false, L("vendorNoStock") end
    end

    local price = vendor:getPrice(itemType, isSellingToVendor)
    local money
    if isSellingToVendor then
        money = vendor:getMoney()
    else
        money = client:getChar():getMoney()
    end

    if money and money < price then return false, isSellingToVendor and L("vendorNoMoney") or L("vendorCanNotAfford") end
    if SteamIDWhitelist or FactionWhitelist or UserGroupWhitelist or VIPOnly then
        local hasWhitelist = true
        local isWhitelisted = false
        local errorMessage
        if SteamIDWhitelist and table.HasValue(SteamIDWhitelist, client:SteamID()) then isWhitelisted = true end
        if FactionWhitelist and table.HasValue(FactionWhitelist, client:Team()) then isWhitelisted = true end
        if UserGroupWhitelist and table.HasValue(UserGroupWhitelist, client:GetUserGroup()) then isWhitelisted = true end
        if VIPOnly and client:isVIP() then isWhitelisted = true end
        if hasWhitelist and not isWhitelisted then
            if SteamIDWhitelist then
                errorMessage = L("vendorSteamIDWhitelist")
            elseif FactionWhitelist then
                errorMessage = L("vendorFactionWhitelist")
            elseif UserGroupWhitelist then
                errorMessage = L("vendorUserGroupWhitelist")
            elseif VIPOnly then
                errorMessage = L("vendorVIPOnly")
            else
                errorMessage = L("vendorNotWhitelisted")
            end
            return false, errorMessage
        end
    end

    if flag and not client:getChar():hasFlags(flag) then return false, L("vendorTradeRestrictedFlag") end
    return true, nil, isWhitelisted
end

if not VENDOR_INVENTORY_MEASURE then
    VENDOR_INVENTORY_MEASURE = lia.inventory.types["grid"]:new()
    VENDOR_INVENTORY_MEASURE.data = {
        w = 8,
        h = 8
    }

    VENDOR_INVENTORY_MEASURE.virtual = true
    VENDOR_INVENTORY_MEASURE:onInstanced()
end

function MODULE:VendorTradeEvent(client, vendor, itemType, isSellingToVendor)
    local canAccess, reason = hook.Run("CanPlayerTradeWithVendor", client, vendor, itemType, isSellingToVendor)
    if canAccess == false then
        if isstring(reason) then client:notifyLocalized(reason) end
        return
    end

    if client.vendorTransaction and client.vendorTimeout > RealTime() then return end
    client.vendorTransaction = true
    client.vendorTimeout = RealTime() + 0.1
    local character = client:getChar()
    local price = vendor:getPrice(itemType, isSellingToVendor)
    if isSellingToVendor then
        local inventory = character:getInv()
        local item = inventory:getFirstItemOfType(itemType)
        if item then
            local context = {
                client = client,
                item = item,
                from = inventory,
                to = VENDOR_INVENTORY_MEASURE
            }

            local canTransfer, transferReason = VENDOR_INVENTORY_MEASURE:canAccess("transfer", context)
            if not canTransfer then
                client:notifyLocalized(transferReason or L("vendorError"))
                client.vendorTransaction = nil
                return
            end

            local canTransferItem, itemTransferReason = hook.Run("CanItemBeTransfered", item, inventory, VENDOR_INVENTORY_MEASURE, client)
            if canTransferItem == false then
                client:notifyLocalized(itemTransferReason or L("vendorError"))
                client.vendorTransaction = nil
                return
            end

            vendor:takeMoney(price)
            character:giveMoney(price)
            item:remove():next(function() client.vendorTransaction = nil end):catch(function() client.vendorTransaction = nil end)
            vendor:addStock(itemType)
            client:notify(L("vendorYouSoldItem", item:getName(), lia.currency.get(price)))
            hook.Run("OnCharTradeVendor", client, vendor, item, isSellingToVendor, character)
        end
    else
        if not character:getInv():doesFitInventory(itemType) then
            client:notifyLocalized("vendorNoInventorySpace")
            hook.Run("OnCharTradeVendor", client, vendor, nil, isSellingToVendor, character, itemType, true)
            client.vendorTransaction = nil
            return
        end

        vendor:giveMoney(price)
        character:takeMoney(price)
        vendor:takeStock(itemType)
        character:getInv():add(itemType):next(function(item)
            client:notify(L("vendorYouBoughtItem", item:getName(), lia.currency.get(price)))
            hook.Run("OnCharTradeVendor", client, vendor, item, isSellingToVendor, character)
            client.vendorTransaction = nil
        end)
    end
end

function MODULE:PlayerAccessVendor(client, vendor)
    vendor:addReceiver(client)
    net.Start("VendorOpen")
    net.WriteEntity(vendor)
    net.Send(client)
    if client:CanEditVendor() then
        for factionID in pairs(vendor.factions) do
            net.Start("VendorAllowFaction")
            net.WriteUInt(factionID, 8)
            net.WriteBool(true)
            net.Send(client)
        end

        for classID in pairs(vendor.classes) do
            net.Start("VendorAllowClass")
            net.WriteUInt(classID, 8)
            net.WriteBool(true)
            net.Send(client)
        end
    end
end

lia.log.addType("vendorAccess", function(client, vendor)
    local vendorName = vendor:getNetVar("name") or "Unknown"
    return L("vendorLogAccess", client:SteamID(), client:Name(), vendorName, client:getChar():getID())
end, "Vendors")

lia.log.addType("vendorExit", function(client, vendor)
    local vendorName = vendor:getNetVar("name") or "Unknown"
    return L("vendorLogExit", client:SteamID(), client:Name(), vendorName, client:getChar():getID())
end, "Vendors")

lia.log.addType("vendorSell", function(client, item, vendor)
    local vendorName = vendor:getNetVar("name") or "Unknown"
    return L("vendorLogSell", client:SteamID(), client:Name(), item, vendorName, client:getChar():getID())
end, "Vendors")

lia.log.addType("vendorEdit", function(client, vendor, key)
    local vendorName = vendor:getNetVar("name") or "Unknown"
    return L("vendorLogEdit", client:SteamID(), client:Name(), vendorName, key, client:getChar():getID())
end, "Vendors")

lia.log.addType("vendorBuy", function(client, item, vendor, isFailed)
    local vendorName = vendor:getNetVar("name") or "Unknown"
    if isFailed then
        return L("vendorLogBuyFail", client:SteamID(), client:Name(), item, vendorName, client:getChar():getID())
    else
        return L("vendorLogBuySuccess", client:SteamID(), client:Name(), item, vendorName, client:getChar():getID())
    end
end, "Vendors")